{% extends 'base.html' %}

{% block content %}
<section class="mb-3 d-flex align-items-start justify-content-between gap-2">
  <div>
    <h1 class="h4 mb-1">Upload Image</h1>
    <div class="d-flex align-items-center">Max file size:<p class="mb-0 scale-up-center-alternate"> Unlimited ‚ôæÔ∏è</p></div>
    {% if active_user and active_user.role == 'admin' %}
    <span class="badge rounded-pill text-bg-warning mb-0 mt-2">{{ 'Admin' if active_user.role == 'admin' else 'User' }}: {{ active_user.username }}</span>
    {% elif active_user and active_user.role == 'user' %}
    <span class="badge rounded-pill text-bg-primary mb-0 mt-2">{{ 'Admin' if active_user.role == 'admin' else 'User' }}: {{ active_user.username }}</span>
    {% else %}
    {% endif %}
  </div>
  <div class="btn-group btn-group-sm" role="group" aria-label="Theme mode">
    <button id="themeLightBtn" type="button" class="btn btn-outline-dark"><i class="bi bi-brightness-high-fill" style="font-size: 18px;"></i></button>
    <button id="themeDarkBtn" type="button" class="btn btn-outline-dark"><i class="bi bi-moon-stars-fill" style="font-size: 18px;"></i></button>
  </div>
</section>

<div class="card border-0 shadow-sm mt-5">
  <div class="card-body p-3 p-md-4">
    {% if not active_user %}
    <div class="alert alert-warning small">
      Anda belum login. Jika ingin punya <strong>gallery sendiri</strong>, silakan <a href="{{ url_for('login') }}">login</a>.
    </div>
    {% endif %}

    <form action="{{ url_for('process_image') }}" method="post" enctype="multipart/form-data" id="uploadForm">
      <div class="mb-3">
        <label for="fileInput" class="form-label">Pilih gambar</label>
        <input
          class="form-control"
          type="file"
          id="fileInput"
          name="file"
          accept=".png,.jpg,.jpeg,.webp"
          multiple
          required
        />
      </div>

      <div id="previewWrap" class="mb-3 d-none">
        <div class="small text-muted mb-2">Preview sebelum remove background:</div>
        <div id="previewGrid" class="d-flex flex-wrap gap-2"></div>
      </div>

      <div id="processState" class="mb-3 d-none">
        <div class="small text-muted mb-1" id="processText">Memulai upload...</div>
        <div class="progress" role="progressbar" aria-label="Progress upload" aria-valuemin="0" aria-valuemax="100">
          <div id="processBar" class="progress-bar progress-bar-striped progress-bar-animated" style="width: 0%">0%</div>
        </div>
        <div class="alert alert-warning small mt-2 d-none text-center" id="extraMessage">
        </div>
      </div>

      {% if not active_user %}
      <div id="guestDownloadWrap" class="mb-3 p-3 text-center d-none">
        <p class="mb-2 small text-success">Upload & proses selesai!</p>
        <button type="button" id="guestDownloadBtn" class="btn btn-success">
          <i class="bi bi-download me-1"></i> Download foto!
        </button>
      </div>
      {% endif %}

      <button id="submitBtn" class="btn btn-dark w-100" type="submit">Remove Background</button>
      <button type="button" class="btn btn-outline-info w-100 mt-2" data-bs-toggle="modal" data-bs-target="#aboutWebModal">Tentang Web</button>
    </form>

    <div class="mt-3 small text-muted">Format: png, jpg, jpeg, webp. Bisa upload banyak gambar sekaligus.</div>

  </div>
</div>

<div class="modal fade" id="aboutWebModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Tentang Web</h5>
      </div>
      <div class="modal-body small">
        Web ini digunakan untuk upload gambar, remove background otomatis, dan menyimpan hasil ke gallery.
        User tamu tetap bisa upload dan langsung download hasilnya, max size file unlimited, aplikasi ini gratis tanpa iklan, dan open source
        <br><br>
        Aplikasi ini dibuat dengan Python Flask, menggunakan library rembg untuk remove background, dan menyimpan data di SQLite. Aplikasi ini juga menggunakan Bootstrap untuk tampilan yang responsif dan modern.
        <br><br>
        link portofolio: <a href="https://trisna-info.pages.dev" target="_blank" rel="noopener">https://trisna-info.pages.dev</a>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-dark btn-dark-modal" data-bs-dismiss="modal">Tutup</button>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
  const fileInput = document.getElementById("fileInput");
  const uploadForm = document.getElementById("uploadForm");
  const submitBtn = document.getElementById("submitBtn");
  const processState = document.getElementById("processState");
  const processText = document.getElementById("processText");
  const processBar = document.getElementById("processBar");
  const extraMessage = document.getElementById("extraMessage");
  const previewWrap = document.getElementById("previewWrap");
  const previewGrid = document.getElementById("previewGrid");

  const themeLightBtn = document.getElementById("themeLightBtn");
  const themeDarkBtn = document.getElementById("themeDarkBtn");
  const guestDownloadWrap = document.getElementById("guestDownloadWrap");
  const guestDownloadBtn = document.getElementById("guestDownloadBtn");

  let selectedFiles = [];
  let waitTimer = null; // timer untuk pesan lambat
  let hideTimer = null; // timer untuk menyembunyikan processState
  let lastDownloadBlob = null;
  let lastDownloadFilename = "";

  function hideProcessStateAfterDelay(delayMs = 2000) {
    if (hideTimer) clearTimeout(hideTimer);
    hideTimer = setTimeout(() => {
      processState.classList.add("d-none");
      extraMessage.textContent = "";
      setProgress(0, "");
      hideTimer = null;
    }, delayMs);
  }

  function updateThemeButtons() {
    const isDark = document.body.classList.contains("theme-dark");
    themeDarkBtn.classList.toggle("btn-outline-white", isDark);
    themeDarkBtn.classList.toggle("btn-white", !isDark);
    themeLightBtn.classList.toggle("btn-dark", !isDark);
    themeLightBtn.classList.toggle("btn-outline-dark", isDark);
  }

  function syncInputFiles() {
    try {
      const dt = new DataTransfer();
      selectedFiles.forEach((file) => dt.items.add(file));
      fileInput.files = dt.files;
    } catch (err) {
      fileInput.value = "";
    }
    fileInput.required = (fileInput.files?.length || 0) === 0;
  }

  function renderPreviews() {
    previewGrid.innerHTML = "";
    if (selectedFiles.length === 0) {
      previewWrap.classList.add("d-none");
      return;
    }

    previewWrap.classList.remove("d-none");
    selectedFiles.forEach((file, index) => {
      const card = document.createElement("div");
      card.className = "position-relative border rounded overflow-hidden";
      card.style.width = "10%";
      card.style.minWidth = "70px";
      card.style.maxWidth = "100px";

      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.className = "btn btn-sm btn-danger position-absolute top-0 end-0 rounded-circle p-0 preview-remove-btn";
      removeBtn.style.width = "22px";
      removeBtn.style.height = "22px";
      removeBtn.style.transform = "translate(25%, -25%)";
      removeBtn.textContent = "x";
      removeBtn.addEventListener("click", () => {
        selectedFiles.splice(index, 1);
        syncInputFiles();
        renderPreviews();
      });

      const img = document.createElement("img");
      img.className = "w-100";
      img.style.aspectRatio = "1 / 1";
      img.style.objectFit = "cover";
      img.alt = file.name;
      img.src = URL.createObjectURL(file);
      img.onload = () => URL.revokeObjectURL(img.src);

      card.appendChild(removeBtn);
      card.appendChild(img);
      previewGrid.appendChild(card);
    });
  }

  function setProgress(percent, text) {
    const p = Math.max(0, Math.min(100, percent));
    processBar.style.width = `${p}%`;
    processBar.textContent = `${p}%`;
    processText.textContent = text;
  }

  function setUploadUiBusy(isBusy) {
    submitBtn.disabled = isBusy;
    fileInput.disabled = isBusy;
    themeLightBtn.disabled = isBusy;
    themeDarkBtn.disabled = isBusy;
    document.querySelectorAll(".preview-remove-btn").forEach((btn) => (btn.disabled = isBusy));
  }

  function clearWaitTimer() {
    if (waitTimer) {
      clearTimeout(waitTimer);
      waitTimer = null;
    }
    extraMessage.classList.add("d-none");
    extraMessage.textContent = ""; // hapus pesan jika timer dibatalkan
  }

  function startWaitTimer() {
    clearWaitTimer(); // pastikan tidak ada timer ganda
    waitTimer = setTimeout(() => {
      extraMessage.classList.remove("d-none");
      extraMessage.textContent = "Mohon di tunggu ya gan, spek home server gw gk bagus2 amat üôèüòÇ";
    }, 10000); // 10 detik
  }

  function parseFileNameFromDisposition(disposition) {
    if (!disposition) return "hasil_removebg";
    const utf8Match = disposition.match(/filename\*=UTF-8''([^;]+)/i);
    if (utf8Match?.[1]) return decodeURIComponent(utf8Match[1]);
    const normalMatch = disposition.match(/filename="?([^";]+)"?/i);
    return normalMatch?.[1] || "hasil_removebg";
  }

  function triggerDownload(blob, filename) {
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    link.remove();
    URL.revokeObjectURL(url);
  }

  fileInput.addEventListener("change", () => {
    selectedFiles = Array.from(fileInput.files || []);
    fileInput.required = selectedFiles.length === 0;
    renderPreviews();
  });

  themeLightBtn.addEventListener("click", () => {
    if (window.setThemeMode) window.setThemeMode("light");
    updateThemeButtons();
  });

  themeDarkBtn.addEventListener("click", () => {
    if (window.setThemeMode) window.setThemeMode("dark");
    updateThemeButtons();
  });

  document.addEventListener("themechange", updateThemeButtons);

  if (guestDownloadBtn && guestDownloadWrap) {
    guestDownloadBtn.addEventListener("click", () => {
      if (lastDownloadBlob && lastDownloadFilename) {
        triggerDownload(lastDownloadBlob, lastDownloadFilename);
        hideProcessStateAfterDelay();
      }
    });
  }

  uploadForm.addEventListener("submit", (event) => {
    event.preventDefault();

    // Sembunyikan tombol Download foto! saat upload baru
    if (guestDownloadWrap) {
      guestDownloadWrap.classList.add("d-none");
      lastDownloadBlob = null;
      lastDownloadFilename = "";
    }

    // Batalkan timer sembunyi jika ada
    if (hideTimer) {
      clearTimeout(hideTimer);
      hideTimer = null;
    }


    // disable semua tombol & link
    const buttons = document.querySelectorAll("button");
    const linkHref = document.querySelectorAll("a");
    linkHref.forEach((link) => {
      link.style.pointerEvents = "none";
      link.style.textDecoration = "none";
      disable = true;
      link.style.opacity = "0.6";
    });
    buttons.forEach((button) => {
      button.disabled = true;
      button.style.pointerEvents = "none";
      button.style.opacity = "0.6";
    });

    const currentFileCount = fileInput.files?.length || selectedFiles.length;
    if (currentFileCount === 0) {
      fileInput.reportValidity();
      return;
    }

    const formData = new FormData(uploadForm);
    processState.classList.remove("d-none");
    extraMessage.textContent = ""; // hapus pesan sebelumnya
    setProgress(0, `Upload 0% (${currentFileCount} file)`);
    setUploadUiBusy(true);

    const xhr = new XMLHttpRequest();
    xhr.open("POST", uploadForm.action, true);
    xhr.responseType = "blob";

    let uploadCompleted = false; // flag untuk tahu kapan upload selesai

    xhr.upload.onprogress = (e) => {
      if (e.lengthComputable) {
        const percent = Math.round((e.loaded / e.total) * 100);
        setProgress(percent, `Upload ${percent}%`);
        if (percent === 100) {
          uploadCompleted = true;
          // Upload selesai, beralih ke status "Memproses"
          setProgress(100, "Upload selesai, memproses gambar...");
          // progress bar tetap 100% tapi kita biarkan animated
          processBar.classList.add("progress-bar-animated");
          // mulai timer untuk pesan lambat
          startWaitTimer();
        }
      } else {
        processText.textContent = "Sedang upload...";
      }
    };

    xhr.onload = () => {
      clearWaitTimer(); // hapus timer pesan lambat

      // enable semua tombol & link
      const buttons = document.querySelectorAll("button");
      const linkHref = document.querySelectorAll("a");
      linkHref.forEach((link) => {
        link.style.pointerEvents = "auto";
        link.style.textDecoration = "none";
        link.disabled = false; // perbaiki: sebelumnya salah tulis "disable"
        link.style.opacity = "1";
      });
      buttons.forEach((button) => {
        button.disabled = false;
        button.style.pointerEvents = "auto";
        button.style.opacity = "1";
      });

      if (xhr.status < 200 || xhr.status >= 300) {
        setProgress(0, "Upload gagal. Coba lagi.");
        setUploadUiBusy(false);
        return;
      }

      const contentType = xhr.getResponseHeader("Content-Type") || "";
      const disposition = xhr.getResponseHeader("Content-Disposition") || "";
      const isAttachment = disposition.toLowerCase().includes("attachment");

      if (isAttachment || contentType.includes("application/zip") || contentType.includes("image/png")) {
        const filename = parseFileNameFromDisposition(disposition);
        lastDownloadBlob = xhr.response;
        lastDownloadFilename = filename;
        setProgress(100, "Upload & proses selesai.");

        // Untuk user belum login: tampilkan tombol Download foto!
        if (guestDownloadWrap) {
          guestDownloadWrap.classList.remove("d-none");
        }

        selectedFiles = [];
        fileInput.value = "";
        fileInput.required = true;
        renderPreviews();
        setUploadUiBusy(false);

        // Sembunyikan processState setelah 2 detik
        
        return;
      }

      // Redirect ke gallery
      setProgress(100, "Upload selesai. Membuka gallery...");
      const nextUrl = xhr.responseURL && xhr.responseURL.length > 0 ? xhr.responseURL : "{{ url_for('gallery_page') }}";
      window.location.href = nextUrl;
    };

    xhr.onerror = () => {
      clearWaitTimer();
      setProgress(0, "Terjadi gangguan jaringan saat upload.");
      setUploadUiBusy(false);
      hideProcessStateAfterDelay();
    };

    xhr.upload.onload = () => {
      // Upload benar-benar selesai (semua data terkirim)
      if (!uploadCompleted) {
        setProgress(100, "Upload selesai, memproses gambar...");
        processBar.classList.add("progress-bar-animated");
        startWaitTimer();
      }
    };

    xhr.onloadstart = () => {
      processBar.classList.add("progress-bar-animated");
      processBar.classList.add("progress-bar-striped");
    };

    // Jika upload.onprogress tidak pernah mencapai 100% (misal file kecil), kita tetap perlu memulai timer saat request selesai dikirim.
    // Tapi idealnya onprogress akan tetap terpanggil. Untuk jaga-jaga, kita bisa mulai timer di onloadstart, lalu reset jika upload selesai lebih cepat.
    // Namun karena kita ingin timer mulai setelah upload selesai, kita mulai di onprogress saat 100%. Tapi jika file sangat kecil, onprogress mungkin langsung 100% tanpa sempat kita deteksi? Sebaiknya mulai timer di sini juga setelah upload selesai.
    // Kita modifikasi: jika upload belum mencapai 100% saat request selesai (misal file 0 byte?), kita tetap mulai timer.
    // Solusi: setelah panggil xhr.send(), kita bisa set timer dengan delay 30 detik, tapi itu akan muncul meskipun upload lama. Tidak tepat.
    // Lebih baik: pantau apakah upload sudah mencapai 100% di onprogress. Jika tidak, saat onloadstart kita set flag bahwa upload belum selesai, dan di onload kita batalkan timer. Tapi jika upload sangat cepat dan onprogress 100% tidak sempat, timer tidak akan pernah dimulai. Untuk amannya, kita mulai timer di onloadstart dengan catatan: jika upload sudah selesai (flag uploadCompleted true), kita batalkan dan mulai ulang? Ini rumit.
    // Pendekatan sederhana: kita mulai timer 30 detik setelah onloadstart, dan batalkan jika response diterima. Dengan asumsi upload biasanya cepat, timer akan tetap berjalan selama proses server. Ini sudah cukup.
    // Tapi kita ingin timer mulai SETELAH upload selesai, bukan sejak awal. Agar lebih akurat, kita bisa mendeteksi akhir upload dari xhr.upload.onload.
    
    xhr.upload.onload = () => {
      // Upload benar-benar selesai (semua data terkirim)
      if (!uploadCompleted) {
        // Jika onprogress tidak sempat memberi 100%, kita set manually
        setProgress(100, "Upload selesai, memproses gambar...");
        processBar.classList.add("progress-bar-animated");
        startWaitTimer();
      }
    };

    xhr.send(formData);
  });

  updateThemeButtons();
</script>
{% endblock %}
